import{k as O,n as K,p as C,s as N}from"./chunk-WHNYGZCR.js";import{b as M,c as m,d as D,e as b}from"./chunk-YJ5RMHHJ.js";function g(n,t,e){let i={};for(let r of n.orbits){let o=t[r.orbitName],a=e[r.orbitName];if(P(r.numOrientations,a))i[r.orbitName]=o;else if(P(r.numOrientations,o))i[r.orbitName]=a;else{let s=new Array(r.numPieces);if(r.numOrientations===1){for(let f=0;f<r.numPieces;f++)s[f]=o.permutation[a.permutation[f]];i[r.orbitName]={permutation:s,orientationDelta:o.orientationDelta}}else{let f=new Array(r.numPieces);for(let u=0;u<r.numPieces;u++)f[u]=(o.orientationDelta[a.permutation[u]]+a.orientationDelta[u])%r.numOrientations,s[u]=o.permutation[a.permutation[u]];i[r.orbitName]={permutation:s,orientationDelta:f}}}}return i}function S(n,t,e){let i={};for(let r of n.orbits){let o=t[r.orbitName],a=e[r.orbitName];if(P(r.numOrientations,a))i[r.orbitName]=o;else{let s=new Array(r.numPieces);if(r.numOrientations===1){for(let u=0;u<r.numPieces;u++)s[u]=o.pieces[a.permutation[u]];let f={pieces:s,orientation:o.orientation};i[r.orbitName]=f}else{let f=new Array(r.numPieces),u=o.orientationMod?new Array(r.numPieces):void 0;for(let c=0;c<r.numPieces;c++){let v=a.permutation[c],I=r.numOrientations;if(o.orientationMod){let k=o.orientationMod[v];u[c]=k,I=k||r.numOrientations}f[c]=(o.orientation[v]+a.orientationDelta[c])%I,s[c]=o.pieces[v]}let A={pieces:s,orientation:f};u&&(A.orientationMod=u),i[r.orbitName]=A}}}return i}var G=!1,U=new Map;function q(n){let t=U.get(n);if(t)return t;let e=new Array(n),i=new Array(n);for(let o=0;o<n;o++)e[o]=o,i[o]=0;let r={permutation:e,orientationDelta:i};return G&&(Object.freeze(e),Object.freeze(i),Object.freeze(r)),U.set(n,r),r}function B(n){let t={};for(let e of n.orbits)t[e.orbitName]=q(e.numPieces);return G&&Object.freeze(t),t}function F(n,t){function e(r,o){let a=r.toString(),s=n.definition.moves[a];if(s)return T(n,s,o);let f=n.definition.derivedMoves?.[a];if(f)return T(n,n.algToTransformation(f).transformationData,o)}let i=e(t.quantum,t.amount)??e(t,1)??e(t.invert,-1);if(i)return i;throw new Error(`Invalid move for KPuzzle (${n.name()}): ${t}`)}var j=class z{constructor(t,e){this.kpuzzle=t,this.patternData=e}toJSON(){return{experimentalPuzzleName:this.kpuzzle.name(),patternData:this.patternData}}static fromTransformation(t){let e=S(t.kpuzzle.definition,t.kpuzzle.definition.defaultPattern,t.transformationData);return new z(t.kpuzzle,e)}apply(t){return this.applyTransformation(this.kpuzzle.toTransformation(t))}applyTransformation(t){if(t.isIdentityTransformation())return new z(this.kpuzzle,this.patternData);let e=S(this.kpuzzle.definition,this.patternData,t.transformationData);return new z(this.kpuzzle,e)}applyMove(t){return this.applyTransformation(this.kpuzzle.moveToTransformation(t))}applyAlg(t){return this.applyTransformation(this.kpuzzle.algToTransformation(t))}isIdentical(t){return H(this.kpuzzle,this.patternData,t.patternData)}experimentalToTransformation(){if(!this.kpuzzle.canConvertDefaultPatternToUniqueTransformation())return null;let t={};for(let[e,i]of Object.entries(this.patternData)){let r={permutation:i.pieces,orientationDelta:i.orientation};t[e]=r}return new h(this.kpuzzle,t)}experimentalIsSolved(t){if(!this.kpuzzle.definition.experimentalIsPatternSolved)throw new Error("`KPattern.experimentalIsPatternSolved()` is not supported for this puzzle at the moment.");return this.kpuzzle.definition.experimentalIsPatternSolved(this,t)}},p,l,h=(l=class{constructor(t,e){D(this,p,void 0);this.kpuzzle=t,this.transformationData=e}toJSON(){return{experimentalPuzzleName:this.kpuzzle.name(),transformationData:this.transformationData}}invert(){return new l(this.kpuzzle,$(this.kpuzzle,this.transformationData))}isIdentityTransformation(){return m(this,p)??b(this,p,this.isIdentical(this.kpuzzle.identityTransformation()))}static experimentalConstructIdentity(t){let e=new l(t,B(t.definition));return b(e,p,!0),e}isIdentical(t){return L(this.kpuzzle,this.transformationData,t.transformationData)}apply(t){return this.applyTransformation(this.kpuzzle.toTransformation(t))}applyTransformation(t){if(this.kpuzzle!==t.kpuzzle)throw new Error(`Tried to apply a transformation for a KPuzzle (${t.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`);return m(this,p)?new l(this.kpuzzle,t.transformationData):m(t,p)?new l(this.kpuzzle,this.transformationData):new l(this.kpuzzle,g(this.kpuzzle.definition,this.transformationData,t.transformationData))}applyMove(t){return this.applyTransformation(this.kpuzzle.moveToTransformation(t))}applyAlg(t){return this.applyTransformation(this.kpuzzle.algToTransformation(t))}toKPattern(){return j.fromTransformation(this)}repetitionOrder(){return V(this.kpuzzle.definition,this)}selfMultiply(t){return new l(this.kpuzzle,T(this.kpuzzle,this.transformationData,t))}},p=new WeakMap,l);function P(n,t){t.permutation||console.log(t);let{permutation:e}=t,i=e.length;for(let r=0;r<i;r++)if(e[r]!==r)return!1;if(n>1){let{orientationDelta:r}=t;for(let o=0;o<i;o++)if(r[o]!==0)return!1}return!0}function J(n,t,e,i={}){for(let r=0;r<n.numPieces;r++)if(!i?.ignorePieceOrientations&&t.orientationDelta[r]!==e.orientationDelta[r]||!i?.ignorePiecePermutation&&t.permutation[r]!==e.permutation[r])return!1;return!0}function L(n,t,e){for(let i of n.definition.orbits)if(!J(i,t[i.orbitName],e[i.orbitName]))return!1;return!0}function R(n,t,e,i={}){for(let r=0;r<n.numPieces;r++)if(!i?.ignorePieceOrientations&&(t.orientation[r]!==e.orientation[r]||(t.orientationMod?.[r]??0)!==(e.orientationMod?.[r]??0))||!i?.ignorePieceIndices&&t.pieces[r]!==e.pieces[r])return!1;return!0}function H(n,t,e){for(let i of n.definition.orbits)if(!R(i,t[i.orbitName],e[i.orbitName]))return!1;return!0}function $(n,t){let e={};for(let i of n.definition.orbits){let r=t[i.orbitName];if(P(i.numOrientations,r))e[i.orbitName]=r;else if(i.numOrientations===1){let o=new Array(i.numPieces);for(let a=0;a<i.numPieces;a++)o[r.permutation[a]]=a;e[i.orbitName]={permutation:o,orientationDelta:r.orientationDelta}}else{let o=new Array(i.numPieces),a=new Array(i.numPieces);for(let s=0;s<i.numPieces;s++){let f=r.permutation[s];o[f]=s,a[f]=(i.numOrientations-r.orientationDelta[s]+i.numOrientations)%i.numOrientations}e[i.orbitName]={permutation:o,orientationDelta:a}}}return e}function T(n,t,e){if(e===1)return t;if(e<0)return T(n,$(n,t),-e);if(e===0){let{transformationData:o}=n.identityTransformation();return o}let i=t;e!==2&&(i=T(n,t,Math.floor(e/2)));let r=g(n.definition,i,i);return e%2===0?r:g(n.definition,t,r)}var Z=class extends K{traverseAlg(n,t){let e=null;for(let i of n.childAlgNodes())e?e=e.applyTransformation(this.traverseAlgNode(i,t)):e=this.traverseAlgNode(i,t);return e??t.identityTransformation()}traverseGrouping(n,t){let e=this.traverseAlg(n.alg,t);return new h(t,T(t,e.transformationData,n.amount))}traverseMove(n,t){return t.moveToTransformation(n)}traverseCommutator(n,t){let e=this.traverseAlg(n.A,t),i=this.traverseAlg(n.B,t);return e.applyTransformation(i).applyTransformation(e.invert()).applyTransformation(i.invert())}traverseConjugate(n,t){let e=this.traverseAlg(n.A,t),i=this.traverseAlg(n.B,t);return e.applyTransformation(i).applyTransformation(e.invert())}traversePause(n,t){return t.identityTransformation()}traverseNewline(n,t){return t.identityTransformation()}traverseLineComment(n,t){return t.identityTransformation()}},Q=C(Z);function x(n,t){return t?x(t,n%t):n}function V(n,t){let e=1;for(let i of n.orbits){let r=t.transformationData[i.orbitName],o=new Array(i.numPieces);for(let a=0;a<i.numPieces;a++)if(!o[a]){let s=a,f=0,u=0;for(;o[s]=!0,f=f+r.orientationDelta[s],u=u+1,s=r.permutation[s],s!==a;);f!==0&&(u=u*i.numOrientations/x(i.numOrientations,Math.abs(f))),e=e*u/x(e,u)}}return e}var w,d,y,E,X=(E=class{constructor(n,t){M(this,"experimentalPGNotation");D(this,w,void 0);D(this,d,new Map);D(this,y,void 0);this.definition=n,this.experimentalPGNotation=t?.experimentalPGNotation}lookupOrbitDefinition(n){return m(this,w)||b(this,w,(()=>{let t={};for(let e of this.definition.orbits)t[e.orbitName]=e;return t})()),m(this,w)[n]}name(){return this.definition.name}identityTransformation(){return h.experimentalConstructIdentity(this)}moveToTransformation(n){typeof n=="string"&&(n=new O(n));let t=n.toString(),e=m(this,d).get(t);if(e)return new h(this,e);if(this.experimentalPGNotation){let r=this.experimentalPGNotation.lookupMove(n);if(!r)throw new Error(`could not map to internal move: ${n}`);return m(this,d).set(t,r),new h(this,r)}let i=F(this,n);return m(this,d).set(t,i),new h(this,i)}algToTransformation(n){return typeof n=="string"&&(n=new N(n)),Q(n,this)}toTransformation(n){return typeof n=="string"?this.algToTransformation(n):n?.is?.(N)?this.algToTransformation(n):n?.is?.(O)?this.moveToTransformation(n):n}defaultPattern(){return new j(this,this.definition.defaultPattern)}canConvertDefaultPatternToUniqueTransformation(){return m(this,y)??b(this,y,(()=>{for(let n of this.definition.orbits){let t=new Array(n.numPieces).fill(!1);for(let e of this.definition.defaultPattern[n.orbitName].pieces)t[e]=!0;for(let e of t)if(!e)return!1}return!0})())}},w=new WeakMap,d=new WeakMap,y=new WeakMap,E);export{j as a,h as b,X as c};
//# sourceMappingURL=chunk-QR7PKRAV.js.map
